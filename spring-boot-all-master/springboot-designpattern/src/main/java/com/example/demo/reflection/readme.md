反射不一样，它是在运行时，而非编译时，动态获取类型的信息，比如接口信息、成员信息、
方法信息、构造方法信息等，根据这些动态获取到的信息创建对象、访问/修改成员、调用方法等。

"Class"类
获取Class对象
类和继承的基本实现原理，我们提到，每个已加载的类在内存都有一份类信息，
每个对象都有指向它所属类信息的引用。Java中，类信息对应的类就是java.lang.Class，
注意不是小写的class，class是定义类的关键字，所有类的根父类Object有一个方法，
可以获取对象的Class对象：
public final native Class<?> getClass()

字段(实例和静态变量)信息
类中定义的静态和实例变量都被称为字段，用类Field表示，位于包java.util.reflect下，
后文涉及到的反射相关的类都位于该包下

方法信息
类中定义的静态和实例方法都被称为方法，用类Method表示，Class有四个获取方法信息的方法：

很多利用反射的库和框架都默认假定类有无参public构造方法，
所以当类利用这些库和框架时要记住提供一个。

类Constructor表示构造方法，通过它可以创建对象，方法为：

慎用反射
反射虽然是灵活的，但一般情况下，并不是我们优先建议的，主要原因是：
反射更容易出现运行时错误，使用显式的类和接口，编译器能帮我们做类型检查，减少错误，但使用反射，类型是运行时才知道的，编译器无能为力
反射的性能要低一些，在访问字段、调用方法前，反射先要查找对应的Field/Method，性能要慢一些

简单的说，如果能用接口实现同样的灵活性，就不要使用反射。

小结
本节介绍了Java中反射相关的主要类和方法，通过入口类Class，可以访问类的各种信息，
如字段、方法、构造方法、父类、接口、泛型信息等，也可以创建和操作对象，调用方法等，
利用这些方法，可以编写通用的、动态灵活的程序，
本节演示了一个简单的通用序列化/反序列化类SimpleMapper。
反射虽然是灵活通用的，但它更容易出现运行时错误，所以，能用接口代替的时候，应该尽量使用接口。